# =============================================================================
# .gitlab-ci.yml - CI/CD Pipeline Configuration
# =============================================================================
stages:
  - validate
  - security-scan
  - build
  - test
  - deploy-staging
  - deploy-production
  - cleanup

variables:
  # Docker registry configuration
  REGISTRY: $CI_REGISTRY
  IMAGE_TAG: $CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA

  # Application configuration
  APP_NAME: wordle
  DEPLOYMENT_TIMEOUT: 600

  # Environment specific variables
  STAGING_HOST: "staging.devstud.imn.htwk-leipzig.de"
  PRODUCTION_HOST: "devstud.imn.htwk-leipzig.de"

# Templates
.docker_template: &docker_template
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2

.ssh_template: &ssh_template
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOYMENT_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

# Validation Stage
validate-environment:
  stage: validate
  image: alpine:latest
  script:
    - |
      echo "Validating environment configuration..."

      # Check required variables
      required_vars=(
        "POSTGRES_PASSWORD" "JWT_SECRET" "REDIS_PASSWORD"
        "OAUTH_GITLAB_CLIENT_ID" "OAUTH_GITLAB_CLIENT_SECRET"
      )

      for var in "${required_vars[@]}"; do
        if [ -z "${!var}" ]; then
          echo "ERROR: Required variable $var is not set"
          exit 1
        fi
      done

      echo "âœ… Environment validation passed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_MERGE_REQUEST_ID

validate-docker-compose:
  stage: validate
  <<: *docker_template
  script:
    - docker-compose -f docker-compose.yml config --quiet
    - echo "âœ… Docker Compose configuration is valid"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_MERGE_REQUEST_ID

# Security Scanning
security-scan-secrets:
  stage: security-scan
  image: alpine/git:latest
  script:
    - |
      echo "Scanning for secrets and sensitive information..."

      # Check for common secret patterns
      if grep -r -E "(password|secret|key|token)\s*[:=]\s*['\"][^'\"]{8,}" . --exclude-dir=.git; then
        echo "âŒ Potential secrets found in code"
        exit 1
      fi

      # Check for hardcoded IPs (except localhost/127.0.0.1)
      if grep -r -E "\b(?!127\.0\.0\.1|localhost)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\b" . --exclude-dir=.git; then
        echo "âš ï¸ Hardcoded IP addresses found - please review"
      fi

      echo "âœ… Security scan completed"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_MERGE_REQUEST_ID

# Build Stage
build-images:
  stage: build
  <<: *docker_template
  script:
    - |
      echo "Building all service images..."

      # Build with cache from registry
      docker-compose build --parallel --pull

      # Tag images for registry
      docker-compose push

      echo "âœ… All images built and pushed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# Test Stage
test-integration:
  stage: test
  <<: *docker_template
  script:
    - |
      echo "Running integration tests..."

      # Start services for testing
      docker-compose -f docker-compose.yml -f docker-compose.test.yml up -d

      # Wait for services to be ready
      timeout 300 bash -c 'until docker-compose exec -T api-gateway curl -f http://localhost:3000/health; do sleep 5; done'

      # Run test suite
      docker-compose exec -T api-gateway npm test

      # Cleanup
      docker-compose down -v

      echo "âœ… Integration tests passed"
  artifacts:
    reports:
      junit: test-results.xml
    paths:
      - coverage/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

test-security:
  stage: test
  <<: *docker_template
  script:
    - |
      echo "Running security tests..."

      # Start minimal services
      docker-compose up -d api-gateway

      # Wait for API Gateway
      timeout 120 bash -c 'until docker-compose exec -T api-gateway curl -f http://localhost:3000/health; do sleep 5; done'

      # Run security tests (example with curl)
      # Test rate limiting
      for i in {1..150}; do
        docker-compose exec -T api-gateway curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health
      done | grep -q "429" && echo "âœ… Rate limiting works" || echo "âŒ Rate limiting failed"

      # Test CORS
      docker-compose exec -T api-gateway curl -H "Origin: http://malicious-site.com" -s -o /dev/null -w "%{http_code}" http://localhost:3000/health

      # Cleanup
      docker-compose down

      echo "âœ… Security tests completed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# Staging Deployment
deploy-staging:
  stage: deploy-staging
  <<: *ssh_template
  variables:
    DEPLOYMENT_HOST: $STAGING_HOST
    ENVIRONMENT: staging
  script:
    - |
      echo "Deploying to staging environment..."

      # Copy deployment files to staging server
      scp -r . dev11@$DEPLOYMENT_HOST:/home/dev11/wordle-staging/

      # Deploy on staging server
      ssh dev11@$DEPLOYMENT_HOST "
        cd /home/dev11/wordle-staging
        
        # Set staging environment variables
        cp .env.staging .env
        
        # Stop existing deployment
        ./stop-all.sh --clean || true
        
        # Start new deployment
        ./start-all.sh --production
        
        # Run health check
        ./health-check.sh
      "

      echo "âœ… Staging deployment completed"
      echo "ðŸŒ Staging URL: http://$STAGING_HOST/dev11"
  environment:
    name: staging
    url: http://$STAGING_HOST/dev11
    on_stop: stop-staging
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual

# Production Deployment
deploy-production:
  stage: deploy-production
  <<: *ssh_template
  variables:
    DEPLOYMENT_HOST: $PRODUCTION_HOST
    ENVIRONMENT: production
  script:
    - |
      echo "Deploying to production environment..."

      # Create backup
      ssh dev11@$PRODUCTION_HOST "
        cd /home/dev11
        if [ -d wordle-production ]; then
          cp -r wordle-production wordle-backup-$(date +%Y%m%d-%H%M%S)
        fi
      "

      # Copy deployment files to production server
      scp -r . dev11@$PRODUCTION_HOST:/home/dev11/wordle-production/

      # Deploy on production server
      ssh dev11@$PRODUCTION_HOST "
        cd /home/dev11/wordle-production
        
        # Set production environment variables
        cp .env.production .env
        
        # Run database migrations first
        ./start-all.sh --migrate-only
        
        # Deploy with zero-downtime strategy
        ./deploy-production.sh
        
        # Verify deployment
        ./health-check.sh
        
        # Run smoke tests
        curl -f http://127.0.10.11:8080/ || exit 1
        curl -f http://127.0.10.11:8082/health || exit 1
      "

      echo "âœ… Production deployment completed"
      echo "ðŸŒ Production URL: http://$PRODUCTION_HOST/dev11"
  environment:
    name: production
    url: http://$PRODUCTION_HOST/dev11
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  when: manual
  allow_failure: false

# Stop staging environment
stop-staging:
  stage: deploy-staging
  <<: *ssh_template
  variables:
    DEPLOYMENT_HOST: $STAGING_HOST
    GIT_STRATEGY: none
  script:
    - ssh dev11@$DEPLOYMENT_HOST "cd /home/dev11/wordle-staging && ./stop-all.sh --clean"
  environment:
    name: staging
    action: stop
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: manual

# Cleanup
cleanup-registry:
  stage: cleanup
  <<: *docker_template
  script:
    - |
      echo "Cleaning up old images from registry..."

      # Keep only last 10 tags per image
      # This is a simplified example - implement based on your registry API

      echo "âœ… Registry cleanup completed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: true
